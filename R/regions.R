#just makes sure that the second and third fields are numbers
getBEDFormat <- function(bedline) {
    lineArgs <- strsplit(bedline, "\t")[[1]]
    if (length(lineArgs)<3) return(NULL)
    #I couldn't figure out any other way of checking if 
    #a field codes an integer
    matches <- grep("^[[:digit:]]+$", lineArgs[2:3])
    if (length(matches) < 2) return(NULL)
    length(lineArgs)
}

# see description below
readRegionsWithScores <- function(path) readRegions(path, keepScore=T)

#reads a bed file up to the 6th field, 
#fields after the 6th are discarded
#by default, also the score field (the 5th) is discarded, but saved if the function is called with readRegionsWithScores
readRegions <- function(path, keepScore=F) {
    stopifnot(length(path)==1)
    #tries to guess the right number of columns and header lines to be skipped
    #should adapt the function bed2GR so that it can parse the metaData
    nLines <- 5
    firstLines <- readLines(path, nLines)
    nFields <- NULL
    for (i in seq_along(firstLines)){
        nFields <- getBEDFormat(firstLines[i])
        if (!is.null(nFields)) break
    }
    if (is.null(nFields)) stop("unable to find a proper bed line in the file")
    #i stores the index of the first proper bed line
    #nFields stores the number of fields
    what <- list(character(), integer(), integer(), character(), double(), character())[1:(min(nFields, 6))]
    if (nFields > 6){
        for (j in 7:nFields){
            what[[j]] <- NULL
        }
    }
    regions <- scan(path, what, sep="\t", skip=(i-1), flush=TRUE, quiet=TRUE)
    
    gr <- GRanges(seqnames=regions[[1]], IRanges(start=regions[[2]]+1, end=regions[[3]]))
    #set the name of the regions
    if (nFields >= 4) names(gr) <- regions[[4]]
    #set scores if desired
    if (keepScore) gr$score <- regions[[5]]
    #set the strand of the regions
    if (nFields >= 6) {
        if (any(!(regions[[6]] %in% c("*",".","+","-")))) {
            warning("invalid strand specification in bed file: ignoring strand")
        } else strand(gr) <- sub("\\.", "*", regions[[6]])
    }

    gr
}

int2str <- function(v) format(v, trim=TRUE, scientific=FALSE)

#writes a bed file up to the 6th field, 
#metadata elements are discarded
#if the strand is present, the score field will be set to 0,
#and if the regions are not named, they will be all named as *
writeRegions <- function(gr, path){
    stopifnot(length(path)==1)
    if (!inherits(gr, "GRanges")) stop("expecting a GRanges object")
    tab <- data.frame(
    chr=      as.character(seqnames(gr)),
    start=    start(gr)-1,
    end=      end(gr))
    
    tab[,2] <- int2str(tab[,2])
    tab[,3] <- int2str(tab[,3])
    
    if (any(strand(gr)!="*")){
        nms <- names(gr)
        if (is.null(nms)) nms <- rep("*", length(gr))
        scores <- rep(0, length(gr))
        tab$name <- nms
        tab$score <- scores
        tab$strand <- as.character(strand(gr))
    } else if (!is.null(names(gr))) tab$name <- names(gr)
    
    write.table(tab, file=path, sep="\t", quote=F, row.names=F, col.names=F)
}

tileRegions <- function(gr, width){
  # This function tiles a GRanges object into bins of a given width
  if (!all((width(gr) %% 100) == 0)) stop('regions widths must be a multiple of the binwidth')
  do.call('c', sapply(1:length(gr), function(i) {
    starts <- seq(start(gr[i]), end(gr[i]), 100)
    gr_i <- GRanges(seqnames=seqnames(gr[i]), ranges=IRanges(start=starts, end=starts+99))
    if(!is.null(gr[i]$name)) gr_i$name <- gr[i]$name
    gr_i
  }))
}

binifyRegions <- function(regions, binsize) {
    if (any(width(regions) %% binsize != 0)) {
        invalidRegions <- regions[width(regions)%%binsize!=0]
        deltaLengths <- width(invalidRegions)%%binsize

        message(length(invalidRegions), " regions are not multiples of the selected bin size ", binsize, ", adjusting...")

        deltaLengths <- sapply(deltaLengths, function(d) ifelse(d>binsize/2, binsize-d, -d))
        end(invalidRegions) <- end(invalidRegions) + deltaLengths
        width(invalidRegions) <- width(invalidRegions) + deltaLengths
        regions[width(regions)%%binsize!=0] <- invalidRegions
    }

    regions
}